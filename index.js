require('dotenv').config();
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const bodyParser = require('body-parser');
const { Pool } = require('pg');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

app.use(cors());
app.use(bodyParser.json());

// JWT ÂØÜÈë∞ÈÖçÁΩÆ
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-key-change-in-production';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';

// Âà§Êñ∑ÊòØÂê¶Âú®ÁîüÁî¢Áí∞Â¢É‰∏îÊ≤íÊúâÊï∏ÊìöÂ∫´
const isProduction = process.env.NODE_ENV === 'production' || process.env.RENDER;
const hasDatabase = process.env.DATABASE_URL;
const useMemoryStore = isProduction && !hasDatabase;

// Âè™Âú®ÊúâÊï∏ÊìöÂ∫´ÊôÇÂàùÂßãÂåñÈÄ£Êé•Ê±†
let pool = null;
if (hasDatabase) {
  pool = new Pool({
    connectionString: process.env.DATABASE_URL || 'postgres://postgres:postgres@postgres:5432/exchange'
  });
}

console.log('üîß Configuration:');
console.log(`   Environment: ${process.env.NODE_ENV || 'development'}`);
console.log(`   Render: ${process.env.RENDER ? 'true' : 'false'}`);
console.log(`   Database URL: ${hasDatabase ? 'configured' : 'not configured'}`);
console.log(`   Memory Store: ${useMemoryStore ? 'enabled' : 'disabled'}`);

// ÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªû
app.get('/health', async (req, res) => {
  try {
    if (useMemoryStore) {
      // Ë®òÊÜ∂È´îÊ®°Âºè - ‰∏çÈúÄË¶ÅÊï∏ÊìöÂ∫´Ê™¢Êü•
      res.status(200).json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        service: 'exchange-backend',
        database: 'memory-store',
        mode: 'memory'
      });
    } else {
      // Êï∏ÊìöÂ∫´Ê®°Âºè - Ê™¢Êü•Êï∏ÊìöÂ∫´ÈÄ£Êé•
      await pool.query('SELECT 1');
      res.status(200).json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        service: 'exchange-backend',
        database: 'connected',
        mode: 'database'
      });
    }
  } catch (error) {
    res.status(503).json({
      status: 'error',
      timestamp: new Date().toISOString(),
      service: 'exchange-backend',
      database: 'disconnected',
      error: error.message
    });
  }
});

// Ë®òÊÜ∂È´îÂ≠òÂÑ≤ÔºàÁï∂Ê≤íÊúâÊï∏ÊìöÂ∫´ÊôÇ‰ΩøÁî®Ôºâ
let memoryStore = {
  users: [],
  orders: [],
  nextUserId: 1,
  nextOrderId: 1
};

// JWT Ë™çË≠â‰∏≠Èñì‰ª∂
const authenticateToken = (req, res, next) => {
  const token = req.headers.auth || req.headers.authorization?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ 
      code: 401, 
      message: 'ÈúÄË¶ÅË™çË≠âtoken', 
      error: 'AUTHENTICATION_REQUIRED' 
    });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ 
      code: 403, 
      message: 'tokenÁÑ°ÊïàÊàñÂ∑≤ÈÅéÊúü', 
      error: 'INVALID_TOKEN' 
    });
  }
};

// Âº∑Âà∂Ë™çË≠â‰∏≠Èñì‰ª∂ - Áî®Êñº‰øÆÊîπÂûãAPI
const requireAuth = (req, res, next) => {
  const token = req.headers.auth || req.headers.authorization?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ 
      code: 401, 
      message: 'Ê≠§Êìç‰ΩúÈúÄË¶ÅË™çË≠â', 
      error: 'AUTHENTICATION_REQUIRED' 
    });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    
    // È©óË≠âÁî®Êà∂ÊòØÂê¶Â≠òÂú®‰∏îÁãÄÊÖãÊ≠£Â∏∏
    pool.query('SELECT id, username, status FROM users WHERE id = $1', [decoded.userId])
      .then(result => {
        if (!result.rows.length) {
          return res.status(403).json({ 
            code: 403, 
            message: 'Áî®Êà∂‰∏çÂ≠òÂú®', 
            error: 'USER_NOT_FOUND' 
          });
        }
        
        const user = result.rows[0];
        if (user.status === 'suspended') {
          return res.status(403).json({ 
            code: 403, 
            message: 'Â∏≥Êà∂Â∑≤Êö´ÂÅú', 
            error: 'ACCOUNT_SUSPENDED' 
          });
        }
        
        req.user.userInfo = user;
        next();
      })
      .catch(err => {
        return res.status(500).json({ 
          code: 500, 
          message: 'Ë™çË≠âÈ©óË≠âÂ§±Êïó', 
          error: 'AUTH_VERIFICATION_FAILED' 
        });
      });
  } catch (error) {
    return res.status(403).json({ 
      code: 403, 
      message: 'tokenÁÑ°ÊïàÊàñÂ∑≤ÈÅéÊúü', 
      error: 'INVALID_TOKEN' 
    });
  }
};

// Wait for DB to be ready with retries
async function waitForDb(retries = 30, delayMs = 2000) {
  for (let i = 0; i < retries; i++) {
    try {
      console.log(`Checking DB connection attempt ${i + 1}/${retries}...`);
      await pool.query('SELECT 1');
      console.log('Database connection successful!');
      return;
    } catch (err) {
      if (i === retries - 1) {
        console.error('Failed to connect to database after all retries:', err.message);
        throw err;
      }
      console.log(`DB not ready, retrying in ${delayMs}ms... (${i + 1}/${retries}) - Error: ${err.message}`);
      await new Promise(r => setTimeout(r, delayMs));
    }
  }
}

// Simple DB init (users + orders + trades)
async function initDb() {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS users (
      id SERIAL PRIMARY KEY,
      username TEXT UNIQUE,
      email TEXT UNIQUE,
      password_hash TEXT,
      balance BIGINT DEFAULT 0,
      status VARCHAR(20) DEFAULT 'active',
      metadata JSONB DEFAULT '{}',
      created_at TIMESTAMP DEFAULT now(),
      updated_at TIMESTAMP DEFAULT now()
    );

    CREATE TABLE IF NOT EXISTS orders (
      id SERIAL PRIMARY KEY,
      user_id INTEGER REFERENCES users(id),
      side VARCHAR(4) NOT NULL, -- 'buy' or 'sell'
      price BIGINT NOT NULL,
      amount BIGINT NOT NULL,
      remaining BIGINT NOT NULL,
      status VARCHAR(16) DEFAULT 'open',
      metadata JSONB DEFAULT '{}',
      created_at TIMESTAMP DEFAULT now()
    );

    CREATE TABLE IF NOT EXISTS trades (
      id SERIAL PRIMARY KEY,
      buy_order_id INTEGER REFERENCES orders(id),
      sell_order_id INTEGER REFERENCES orders(id),
      price BIGINT NOT NULL,
      amount BIGINT NOT NULL,
      created_at TIMESTAMP DEFAULT now()
    );

    CREATE TABLE IF NOT EXISTS user_sessions (
      id SERIAL PRIMARY KEY,
      user_id INTEGER REFERENCES users(id),
      token_hash TEXT NOT NULL,
      expires_at TIMESTAMP NOT NULL,
      created_at TIMESTAMP DEFAULT now()
    );

    CREATE TABLE IF NOT EXISTS balance_logs (
      id SERIAL PRIMARY KEY,
      user_id INTEGER REFERENCES users(id),
      operator_id INTEGER REFERENCES users(id),
      old_balance BIGINT NOT NULL,
      new_balance BIGINT NOT NULL,
      delta BIGINT NOT NULL,
      reason TEXT DEFAULT '',
      created_at TIMESTAMP DEFAULT now()
    );

    -- ÁÇ∫ordersË°®Êñ∞Â¢ûÂøÖË¶ÅÊ¨Ñ‰Ωç
    ALTER TABLE orders ADD COLUMN IF NOT EXISTS symbol VARCHAR(20) DEFAULT 'BTCUSDT';
    ALTER TABLE orders ADD COLUMN IF NOT EXISTS type VARCHAR(10) DEFAULT 'limit';
    ALTER TABLE orders ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT now();
  `);
}

// initialize with DB readiness retry
// initialize with DB readiness retry and initDb retry
async function ensureDbInit(retries = 5, delayMs = 2000) {
  try {
    console.log('Starting database initialization...');
    await waitForDb(30, 3000);
  } catch (err) {
    console.error('waitForDb failed', err);
    throw err;
  }

  for (let i = 0; i < retries; i++) {
    try {
      console.log(`initDb attempt ${i + 1}/${retries}`);
      await initDb();
      console.log('Database tables initialized successfully!');
      return;
    } catch (err) {
      console.error(`initDb failed on attempt ${i + 1}:`, err.message);
      if (i === retries - 1) throw err;
      await new Promise(r => setTimeout(r, delayMs));
    }
  }
}

// ÂïüÂãïÊáâÁî®
async function startApplication() {
  try {
    console.log('Starting application...');
    
    // Âè™Âú®ÊúâÊï∏ÊìöÂ∫´ÊôÇÂàùÂßãÂåñÊï∏ÊìöÂ∫´
    if (!useMemoryStore) {
      console.log('üóÑÔ∏è Initializing database...');
      await ensureDbInit();
      console.log('üìä Database initialized and ready');
    } else {
      console.log('üíæ Using memory store (no database required)');
    }
    
    // ÂïüÂãïHTTPÊúçÂãôÂô®
    const PORT = process.env.PORT || 3000;
    server.listen(PORT, () => {
      console.log(`üöÄ Backend server listening on port ${PORT}`);
      console.log(`üîê JWT authentication enabled`);
      if (useMemoryStore) {
        console.log('‚ö†Ô∏è  Memory store mode - data will not persist between restarts');
      }
    });
    
  } catch (err) {
    console.error('‚ùå Failed to start application:', err);
    process.exit(1);
  }
}

// ÂïüÂãïÊáâÁî®
startApplication();

// Â∑•ÂÖ∑ÂáΩÊï∏
const generateToken = (userId, username) => {
  return jwt.sign(
    { userId, username },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES_IN }
  );
};

// Ë™çË≠âÁõ∏ÈóúAPI (ÁÑ°ÈúÄtoken)
app.post('/api/auth/register', async (req, res) => {
  const { username, email, password } = req.body;
  
  if (!username || !email || !password) {
    return res.status(400).json({ 
      code: 400, 
      message: 'Áî®Êà∂Âêç„ÄÅ‰ø°ÁÆ±ÂíåÂØÜÁ¢ºÁÇ∫ÂøÖÂ°´È†ÖÁõÆ' 
    });
  }

  try {
    const hashedPassword = await bcrypt.hash(password, 12);
    
    if (useMemoryStore) {
      // Ë®òÊÜ∂È´îÂ≠òÂÑ≤Ê®°Âºè
      const existingUser = memoryStore.users.find(u => 
        u.username === username || u.email === email
      );
      
      if (existingUser) {
        return res.status(409).json({ 
          code: 409, 
          message: 'Áî®Êà∂ÂêçÊàñ‰ø°ÁÆ±Â∑≤Â≠òÂú®' 
        });
      }
      
      const user = {
        id: memoryStore.nextUserId++,
        username,
        email,
        password_hash: hashedPassword,
        status: 'active',
        balance: 0,
        created_at: new Date()
      };
      
      memoryStore.users.push(user);
      const token = generateToken(user.id, user.username);
      
      res.json({
        code: 200,
        message: 'Ë®ªÂÜäÊàêÂäü',
        data: {
          user: { id: user.id, username: user.username, email: user.email },
          token
        }
      });
    } else {
      // Êï∏ÊìöÂ∫´Ê®°Âºè
      const r = await pool.query(
        'INSERT INTO users(username, email, password_hash) VALUES($1, $2, $3) RETURNING id, username, email',
        [username, email, hashedPassword]
      );
      
      const user = r.rows[0];
      const token = generateToken(user.id, user.username);
      
      res.json({
        code: 200,
        message: 'Ë®ªÂÜäÊàêÂäü',
        data: {
          user: { id: user.id, username: user.username, email: user.email },
          token
        }
      });
    }
  } catch (err) {
    if (err.code === '23505') {
      return res.status(409).json({ 
        code: 409, 
        message: 'Áî®Êà∂ÂêçÊàñ‰ø°ÁÆ±Â∑≤Â≠òÂú®' 
      });
    }
    res.status(500).json({ 
      code: 500, 
      message: 'Ë®ªÂÜäÂ§±Êïó',
      error: err.message 
    });
  }
});

app.post('/api/auth/login', async (req, res) => {
  const { username, password } = req.body;
  
  if (!username || !password) {
    return res.status(400).json({ 
      code: 400, 
      message: 'Áî®Êà∂ÂêçÂíåÂØÜÁ¢ºÁÇ∫ÂøÖÂ°´È†ÖÁõÆ' 
    });
  }

  try {
    let user;
    
    if (useMemoryStore) {
      // Ë®òÊÜ∂È´îÂ≠òÂÑ≤Ê®°Âºè
      user = memoryStore.users.find(u => 
        u.username === username || u.email === username
      );
      
      if (!user) {
        return res.status(401).json({ 
          code: 401, 
          message: 'Áî®Êà∂ÂêçÊàñÂØÜÁ¢ºÈåØË™§' 
        });
      }
    } else {
      // Êï∏ÊìöÂ∫´Ê®°Âºè
      const r = await pool.query(
        'SELECT id, username, email, password_hash, status FROM users WHERE username = $1 OR email = $1',
        [username]
      );
      
      if (!r.rows.length) {
        return res.status(401).json({ 
          code: 401, 
          message: 'Áî®Êà∂ÂêçÊàñÂØÜÁ¢ºÈåØË™§' 
        });
      }
      
      user = r.rows[0];
    }
    
    if (user.status !== 'active') {
      return res.status(403).json({ 
        code: 403, 
        message: 'Â∏≥Êà∂Â∑≤Ë¢´Êö´ÂÅú' 
      });
    }

    const isValidPassword = await bcrypt.compare(password, user.password_hash);
    
    if (!isValidPassword) {
      return res.status(401).json({ 
        code: 401, 
        message: 'Áî®Êà∂ÂêçÊàñÂØÜÁ¢ºÈåØË™§' 
      });
    }

    const token = generateToken(user.id, user.username);
    
    res.json({
      code: 200,
      message: 'ÁôªÂÖ•ÊàêÂäü',
      data: {
        user: { id: user.id, username: user.username, email: user.email },
        token
      }
    });
  } catch (err) {
    res.status(500).json({ 
      code: 500, 
      message: 'ÁôªÂÖ•Â§±Êïó',
      error: err.message 
    });
  }
});

// Token È©óË≠â API
app.post('/api/auth/verify', authenticateToken, async (req, res) => {
  try {
    const user = await pool.query(
      'SELECT id, username, email, status FROM users WHERE id = $1',
      [req.user.userId]
    );
    
    if (!user.rows.length) {
      return res.status(404).json({ 
        code: 404, 
        message: 'Áî®Êà∂‰∏çÂ≠òÂú®' 
      });
    }

    res.json({
      code: 200,
      message: 'TokenÊúâÊïà',
      data: { user: user.rows[0] }
    });
  } catch (err) {
    res.status(500).json({ 
      code: 500, 
      message: 'TokenÈ©óË≠âÂ§±Êïó' 
    });
  }
});

// Êü•Ë©¢API (ÈúÄË¶ÅÂü∫Êú¨Ë™çË≠â)
app.get('/api/users', authenticateToken, async (req, res) => {
  try {
    const r = await pool.query('SELECT id, username, email, balance, status, created_at FROM users ORDER BY id DESC');
    res.json({
      code: 200,
      data: r.rows
    });
  } catch (err) {
    res.status(500).json({ 
      code: 500, 
      message: 'Êü•Ë©¢Â§±Êïó',
      error: err.message 
    });
  }
});

app.get('/api/users/:id', authenticateToken, async (req, res) => {
  try {
    const r = await pool.query('SELECT id, username, email, balance, status, created_at FROM users WHERE id = $1', [req.params.id]);
    if (!r.rows.length) {
      return res.status(404).json({ 
        code: 404, 
        message: 'Áî®Êà∂‰∏çÂ≠òÂú®' 
      });
    }
    res.json({
      code: 200,
      data: r.rows[0]
    });
  } catch (err) {
    res.status(500).json({ 
      code: 500, 
      message: 'Êü•Ë©¢Â§±Êïó',
      error: err.message 
    });
  }
});

// ‰øÆÊîπÂûãAPI (Âº∑Âà∂Ë™çË≠â)
app.post('/api/users/:id/balance', requireAuth, async (req, res) => {
  const id = req.params.id;
  const { delta, reason } = req.body; // delta in cents, reason for audit
  
  // È©óË≠âÊ¨äÈôêÔºöÂè™ËÉΩ‰øÆÊîπËá™Â∑±ÁöÑÈ§òÈ°çÊàñÁÆ°ÁêÜÂì°Ê¨äÈôê
  if (req.user.userId != id && req.user.role !== 'admin') {
    return res.status(403).json({ 
      code: 403, 
      message: 'ÁÑ°Ê¨äÈôê‰øÆÊîπÊ≠§Áî®Êà∂È§òÈ°ç' 
    });
  }
  
  if (!delta || typeof delta !== 'number') {
    return res.status(400).json({ 
      code: 400, 
      message: 'È§òÈ°çËÆäÂãïÂÄºÁÇ∫ÂøÖÂ°´‰∏îÂøÖÈ†àÁÇ∫Êï∏Â≠ó' 
    });
  }

  try {
    await pool.query('BEGIN');
    
    const cur = await pool.query('SELECT balance FROM users WHERE id=$1 FOR UPDATE', [id]);
    if (!cur.rows.length) {
      await pool.query('ROLLBACK');
      return res.status(404).json({ 
        code: 404, 
        message: 'Áî®Êà∂‰∏çÂ≠òÂú®' 
      });
    }
    
    const currentBalance = BigInt(cur.rows[0].balance || 0);
    const deltaAmount = BigInt(delta);
    const newBalance = currentBalance + deltaAmount;
    
    // Èò≤Ê≠¢È§òÈ°çÁÇ∫Ë≤†Êï∏
    if (newBalance < 0) {
      await pool.query('ROLLBACK');
      return res.status(400).json({ 
        code: 400, 
        message: 'È§òÈ°ç‰∏çË∂≥ÔºåÁÑ°Ê≥ïÂü∑Ë°åÊ≠§Êìç‰Ωú' 
      });
    }
    
    await pool.query('UPDATE users SET balance=$1, updated_at=now() WHERE id=$2', [newBalance.toString(), id]);
    
    // Ë®òÈåÑÊìç‰ΩúÊó•Ë™å (audit log)
    await pool.query(
      'INSERT INTO balance_logs (user_id, operator_id, old_balance, new_balance, delta, reason, created_at) VALUES ($1, $2, $3, $4, $5, $6, now())',
      [id, req.user.userId, currentBalance.toString(), newBalance.toString(), deltaAmount.toString(), reason || 'È§òÈ°çË™øÊï¥']
    );
    
    await pool.query('COMMIT');
    
    const r2 = await pool.query('SELECT id, username, balance FROM users WHERE id=$1', [id]);
    const user = r2.rows[0];
    
    io.emit('user:balance:updated', { 
      userId: user.id, 
      username: user.username, 
      balance: user.balance,
      operator: req.user.username 
    });
    
    res.json({
      code: 200,
      message: 'È§òÈ°çÊõ¥Êñ∞ÊàêÂäü',
      data: user
    });
  } catch (err) {
    await pool.query('ROLLBACK');
    res.status(500).json({ 
      code: 500, 
      message: 'È§òÈ°çÊõ¥Êñ∞Â§±Êïó',
      error: err.message 
    });
  }
});

// ‰∏ãÂñÆAPI (Âº∑Âà∂Ë™çË≠â)
app.post('/api/orders', requireAuth, async (req, res) => {
  const { symbol, side, price, amount, type = 'limit' } = req.body;
  
  if (!symbol || !side || !price || !amount) {
    return res.status(400).json({ 
      code: 400, 
      message: 'Ë®ÇÂñÆÂèÉÊï∏‰∏çÂÆåÊï¥' 
    });
  }
  
  if (!['buy', 'sell'].includes(side)) {
    return res.status(400).json({ 
      code: 400, 
      message: 'Ë®ÇÂñÆÊñπÂêëÂøÖÈ†àÁÇ∫buyÊàñsell' 
    });
  }

  try {
    await pool.query('BEGIN');
    
    // Ê™¢Êü•Áî®Êà∂È§òÈ°ç
    const userResult = await pool.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [req.user.userId]);
    if (!userResult.rows.length) {
      await pool.query('ROLLBACK');
      return res.status(404).json({ 
        code: 404, 
        message: 'Áî®Êà∂‰∏çÂ≠òÂú®' 
      });
    }
    
    const userBalance = BigInt(userResult.rows[0].balance);
    const orderValue = BigInt(Math.floor(price * amount * 100)); // convert to cents
    
    if (side === 'buy' && userBalance < orderValue) {
      await pool.query('ROLLBACK');
      return res.status(400).json({ 
        code: 400, 
        message: 'È§òÈ°ç‰∏çË∂≥' 
      });
    }
    
    // ÂâµÂª∫Ë®ÇÂñÆ
    const orderResult = await pool.query(
      'INSERT INTO orders (user_id, symbol, side, price, amount, remaining, type, status, created_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, now()) RETURNING *',
      [req.user.userId, symbol, side, BigInt(Math.floor(price * 100)), BigInt(Math.floor(amount * 100)), BigInt(Math.floor(amount * 100)), type, 'open']
    );
    
    const order = orderResult.rows[0];
    
    // Â¶ÇÊûúÊòØË≤∑ÂñÆÔºåÊâ£Èô§È§òÈ°ç
    if (side === 'buy') {
      await pool.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [orderValue.toString(), req.user.userId]);
    }
    
    await pool.query('COMMIT');
    
    io.emit('order:created', {
      ...order,
      username: req.user.username
    });
    
    res.json({
      code: 200,
      message: 'Ë®ÇÂñÆÂâµÂª∫ÊàêÂäü',
      data: order
    });
  } catch (err) {
    await pool.query('ROLLBACK');
    res.status(500).json({ 
      code: 500, 
      message: 'Ë®ÇÂñÆÂâµÂª∫Â§±Êïó',
      error: err.message 
    });
  }
});

// ÂèñÊ∂àË®ÇÂñÆAPI (Âº∑Âà∂Ë™çË≠â)
app.delete('/api/orders/:orderId', requireAuth, async (req, res) => {
  const orderId = req.params.orderId;
  
  try {
    await pool.query('BEGIN');
    
    const orderResult = await pool.query(
      'SELECT * FROM orders WHERE id = $1 AND user_id = $2 FOR UPDATE',
      [orderId, req.user.userId]
    );
    
    if (!orderResult.rows.length) {
      await pool.query('ROLLBACK');
      return res.status(404).json({ 
        code: 404, 
        message: 'Ë®ÇÂñÆ‰∏çÂ≠òÂú®ÊàñÁÑ°Ê¨äÈôêÂèñÊ∂à' 
      });
    }
    
    const order = orderResult.rows[0];
    
    if (order.status !== 'open') {
      await pool.query('ROLLBACK');
      return res.status(400).json({ 
        code: 400, 
        message: 'Âè™ËÉΩÂèñÊ∂àÊú™Êàê‰∫§ÁöÑË®ÇÂñÆ' 
      });
    }
    
    // Êõ¥Êñ∞Ë®ÇÂñÆÁãÄÊÖã
    await pool.query('UPDATE orders SET status = $1, updated_at = now() WHERE id = $2', ['cancelled', orderId]);
    
    // Â¶ÇÊûúÊòØË≤∑ÂñÆÔºåÈÄÄÈÇÑÈ§òÈ°ç
    if (order.side === 'buy') {
      const refundAmount = BigInt(order.remaining) * BigInt(order.price) / BigInt(100);
      await pool.query('UPDATE users SET balance = balance + $1 WHERE id = $2', [refundAmount.toString(), req.user.userId]);
    }
    
    await pool.query('COMMIT');
    
    io.emit('order:cancelled', {
      orderId: order.id,
      userId: req.user.userId,
      username: req.user.username
    });
    
    res.json({
      code: 200,
      message: 'Ë®ÇÂñÆÂèñÊ∂àÊàêÂäü'
    });
  } catch (err) {
    await pool.query('ROLLBACK');
    res.status(500).json({ 
      code: 500, 
      message: 'Ë®ÇÂñÆÂèñÊ∂àÂ§±Êïó',
      error: err.message 
    });
  }
});

// ÂâçÁ´ØÊúüÊúõÁöÑÁº∫Â§± API Á´ØÈªû
// Èå¢ÂåÖË≤®Âπ£Á´ØÈªû
app.post('/api/anon/v1/wallet/currency', (req, res) => {
  res.json({
    code: 200,
    data: [
      { id: 1, symbol: 'USDT', name: 'Tether USD', balance: 1000.00 },
      { id: 2, symbol: 'BTC', name: 'Bitcoin', balance: 0.001 },
      { id: 3, symbol: 'ETH', name: 'Ethereum', balance: 0.1 }
    ]
  });
});

// ÊîØÊè¥ÂàóË°®Á´ØÈªû
app.post('/api/anon/v1/support/list', (req, res) => {
  res.json({
    code: 200,
    data: []
  });
});

// ÈÄöÁü•ÂàóË°®Á´ØÈªû
app.post('/api/anon/v1/notice/list', (req, res) => {
  res.json({
    code: 200,
    data: []
  });
});

// ÈÄöË®ä token Á´ØÈªû
app.post('/api/anon/v1/comm/token', (req, res) => {
  res.json({
    code: 200,
    data: {
      token: 'mock-session-token',
      expires: Date.now() + 3600000
    }
  });
});

// ÂêàÁ¥ÑÈ†ÖÁõÆÁ´ØÈªû
app.post('/api/anon/v22/contract/item', (req, res) => {
  res.json({
    code: 200,
    data: []
  });
});

// Socket
io.on('connection', socket => {
  console.log('socket connected', socket.id);
});

// ÂïüÂãïÊúçÂãôÂô®
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`üéâ ÊúçÂãôÂ∑≤‰∏äÁ∑ö`);
  console.log(`üîó ÂæåÁ´ØÁ∂≤ÂùÄ: https://anplifyx1688-backend.onrender.com`);
  console.log(`üì° API Âü∫Êú¨ URL: http://localhost:${PORT}/api`);
  console.log(`üè• ÂÅ•Â∫∑Ê™¢Êü•: http://localhost:${PORT}/health`);
  console.log(`üìù ÊåáÂÆöÁ∂≤ÂüüÁöÑ‰∫§ÂèãURL: https://render.com/docs/web-services#port-binding`);
});